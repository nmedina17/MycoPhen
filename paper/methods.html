<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>methods</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="methods_files/libs/clipboard/clipboard.min.js"></script>
<script src="methods_files/libs/quarto-html/quarto.js"></script>
<script src="methods_files/libs/quarto-html/popper.min.js"></script>
<script src="methods_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="methods_files/libs/quarto-html/anchor.min.js"></script>
<link href="methods_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="methods_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="methods_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="methods_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="methods_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="study-site" class="level2">
<h2 class="anchored" data-anchor-id="study-site"><strong>Study site</strong></h2>
<p>This study was conducted using a subset of five from 38 mono-dominant forestry plots at the Morton Arboretum in Lisle, Illinois, USA (41.81 N, 88.05 W), as initially described by <em><span class="citation" data-cites="midgley2020">Midgley and Sims (<a href="#ref-midgley2020" role="doc-biblioref">2020</a>)</span></em>. Briefly, this setup resembles a common garden experiment, as most plots do not vary significantly in soil chemistry, even between distinct yet similar Alfisol and Mollisol soil orders <em><span class="citation" data-cites="midgley2020">(<a href="#ref-midgley2020" role="doc-biblioref">Midgley and Sims 2020</a>)</span></em>. Mean annual air temperature is 7-29 C and mean annual precipitation is near 1000 mm since the year 2008, with an aboveground growing season from April to October <em>(U.S. Climate Data)</em>. Soil moisture and temperature data were collected at the site level using HOBO data loggers (Onset Computer Corporation, Bourne, MA, USA) installed at 10 cm depth in the topsoil. The five mono-dominant host tree species plots used in this study were: <em>Carya ovata</em> (shagbark hickory), <em>Quercus alba</em> (white oak), <em>Quercus bicolor</em> (swamp white oak), <em>Picea abies</em> (Norway spruce), and <em>Pinus strobus</em> (Eastern white pine). All five plots showed similar soil chemistry and were on Alfisol soils, except <em>Q. bicolor</em>, which was on a Mollisol soil <em><span class="citation" data-cites="midgley2020">(<a href="#ref-midgley2020" role="doc-biblioref">Midgley and Sims 2020</a>)</span></em>. However, the five monodominant host tree species varied in leaf habit, i.e.&nbsp;evergreen and deciduous, which in this case, but not among all 38 forestry plots, also aligned with plant division, i.e.&nbsp;gymnosperm and angiosperm, respectively.</p>
</section>
<section id="soil-sampling" class="level2">
<h2 class="anchored" data-anchor-id="soil-sampling"><strong>Soil sampling</strong></h2>
<p>In each forestry plot, six 30 x 160 cm subplots were established to sample from a consistent area. Soils were sampled along 160 cm transect to 10 cm depth using a sterile round 1 cm-wide metal tube. For each collection period, soil samples were collected 20 cm apart along the transect and stored in a cooler containing frozen ice packs until taken back to the lab where they were processed and subsampled the same day. Soil subsamples were stored in 2-mL screw-cap vials at -80 C for up to six months until lyophilization and DNA extraction. Approximately two weeks before beginning DNA extraction, all samples were lyophilized at the same time and stored in a cabinet at room temperature until DNA extraction was completed two months later.</p>
</section>
<section id="dna-extraction-and-sequencing" class="level2">
<h2 class="anchored" data-anchor-id="dna-extraction-and-sequencing"><strong>DNA extraction and sequencing</strong></h2>
<p>Approximately 0.25 g of soil was subsampled and used for DNA extraction with Qiagen DNeasy PowerSoil Pro kits following the manufacturer’s protocol, but homogenized for 30 sec at 4000 rpm using the MP FastPrep tissue homogenizer. DNA was stored at -80 C for approximately two months until shipped for sequencing. DNA extractions then underwent library preparation according to <em><span class="citation" data-cites="gohl2016">(<a href="#ref-gohl2016" role="doc-biblioref"><strong>gohl2016?</strong></a>)</span></em> followed by sequencing of the <em>ITS2</em> region using <em>5.8SR</em> (<em>TCGATGAAGAACGCAGCG</em>) and <em>ITS4</em> (<em>TCCTCCGCTTATTGATATGC</em>) primers on the Illumina NextSeq platform by the University of Minnesota Genomics Center.</p>
</section>
<section id="quantitative-pcr-qpcr" class="level2">
<h2 class="anchored" data-anchor-id="quantitative-pcr-qpcr"><strong>Quantitative PCR (qPCR)</strong></h2>
<p>To approximate fungal biomass, we ran quantitative (i.e.&nbsp;real-time) PCR <em><span class="citation" data-cites="tellenbach2010">(<a href="#ref-tellenbach2010" role="doc-biblioref"><strong>tellenbach2010?</strong></a>)</span></em> on the DNA extracts in duplicate on a <strong>Bio-Rad XXXX Real-Time System</strong> and prepared using the <strong>Bio-Rad SsoAdvanced Universal SYBR Green Supermix</strong>. We targeted the 18S ribosomal DNA region using general fungal-specific primers <strong>XXXX (sequence) and XXXX (sequence)</strong> to reduce primer bias <em><span class="citation" data-cites="bellemain2010">(<a href="#ref-bellemain2010" role="doc-biblioref"><strong>bellemain2010?</strong></a>)</span></em> against ECM fungi that are rarer or show some variation in ITS2 copy numbers <em><span class="citation" data-cites="janowski023">(<a href="#ref-janowski023" role="doc-biblioref"><strong>janowski023?</strong></a>)</span></em>. While qPCR to approximate fungal biomass is not unbiased, neither are alternative methods such as hyphal ingrowth bags <strong><span class="citation" data-cites="zuev2019">(<a href="#ref-zuev2019" role="doc-biblioref"><strong>zuev2019?</strong></a>)</span></strong>.</p>
</section>
<section id="bioinformatics" class="level2">
<h2 class="anchored" data-anchor-id="bioinformatics"><strong>Bioinformatics</strong></h2>
<p>Raw sequences were processed through the DADA2 pipeline for R <em><span class="citation" data-cites="callahan2016">(<a href="#ref-callahan2016" role="doc-biblioref"><strong>callahan2016?</strong></a>)</span></em> using the University of Minnesota high-performance computing cluster. Both forward and reverse reads <strong>with &gt;80% quality scores</strong> were paired and used for downstream processing. DADA2 learns sequence error rates from the full input dataset using a naive bayesian classifier <em><span class="citation" data-cites="wang007">(<a href="#ref-wang007" role="doc-biblioref"><strong>wang007?</strong></a>)</span></em> and then clusters sequences into Amplicon Sequence Variants (ASVs) based on 99% sequence similarity <em><span class="citation" data-cites="callahan2017">(<a href="#ref-callahan2017" role="doc-biblioref"><strong>callahan2017?</strong></a>)</span></em>, which allow more taxonomic resolution but with similar ecological results compared to traditional operational taxonomic units (OTUs) based on 97% sequence similarity <em><span class="citation" data-cites="glassman2018">(<a href="#ref-glassman2018" role="doc-biblioref"><strong>glassman2018?</strong></a>)</span></em>. ASVs are increasingly adopted and are helpful to more finely resolve fungal diversity and function. ASV identities were quality-controlled by filtering out those formed by sequencing noise, which were considered ASVs with fewer than ten reads <em><span class="citation" data-cites="lindahl2013">(<a href="#ref-lindahl2013" role="doc-biblioref"><strong>lindahl2013?</strong></a>)</span></em>. Final ASVs were assigned taxonomy using the UNITE database <em><span class="citation" data-cites="abarenkov2010 abarenkov2024">(<a href="#ref-abarenkov2010" role="doc-biblioref"><strong>abarenkov2010?</strong></a>; <a href="#ref-abarenkov2024" role="doc-biblioref"><strong>abarenkov2024?</strong></a>)</span></em> <strong>v####</strong>, and lifestyle traits including exploration types were assigned using the FungalTraits database <em><span class="citation" data-cites="polme2020">(<a href="#ref-polme2020" role="doc-biblioref"><strong>polme2020?</strong></a>)</span></em> which is preferred to FUNGuild <em><span class="citation" data-cites="tanunchai2023">(<a href="#ref-tanunchai2023" role="doc-biblioref"><strong>tanunchai2023?</strong></a>)</span></em>.</p>
</section>
<section id="statistics" class="level2">
<h2 class="anchored" data-anchor-id="statistics"><strong>Statistics</strong></h2>
<section id="data-cleaning" class="level3">
<h3 class="anchored" data-anchor-id="data-cleaning"><em>Data cleaning</em></h3>
<p>All statistics were done in R version 4.4 (R Core Team 2024). Site-level topsoil temperature and moisture data were smoothed using rolling averages from the previous week and <strong>filtered for those values on sampling dates; soil moisture and temperature were combined / only soil moisture values were used as they were highly correlated (r &gt; 0.7)</strong>. To compare communities, we rarefied to the most common lowest number of observed sequences across samples, which was approximately 50,000 reads and excluded five samples; rarefaction is currently the most widely accepted approach for microbiome data <em><span class="citation" data-cites="schloss2024">(<a href="#ref-schloss2024" role="doc-biblioref"><strong>schloss2024?</strong></a>)</span></em>. Genus-level abundances were calculated as sums of the abundances of each ASV in the genus, and the same was done for abundances at the exploration type level. Among subplots within a forest plot, genus- and group-level data were centered using median values, including in cases where trends are shown across all forest stand species. To reduce potential effects of extreme values on statistical models, plot-level outliers in the qPCR data were removed using prep_outliers() function in the ‘funModeling’ R package (<strong><span class="citation" data-cites="CITE">(<a href="#ref-CITE" role="doc-biblioref"><strong>CITE?</strong></a>)</span></strong>).</p>
<p>Diversity calculations and whole-community ordination analyses were done using the ‘vegan’ package (<a href="https://vegandevs.github.io/vegan/authors.html"><strong>Oksanen et al 2024</strong></a>).</p>
</section>
<section id="time-series" class="level3">
<h3 class="anchored" data-anchor-id="time-series"><em>Time-series</em></h3>
<p>Time series data were analyzed using generalized additive mixed models (GAMMs), as implemented in the ‘gamm4’ package (<a href="https://cran.r-universe.dev/gamm4/citation"><strong>Wood and Scheipl 2020</strong></a>), which is based on GAMs from mgcv (<strong><span class="citation" data-cites="CITE">(<a href="#ref-CITE" role="doc-biblioref"><strong>CITE?</strong></a>)</span></strong>) but modified to use syntax of more traditional linear mixed-effects model structures (e.g.&nbsp;GLMM) that are used in ‘lme4’ (<strong><span class="citation" data-cites="CITE">(<a href="#ref-CITE" role="doc-biblioref"><strong>CITE?</strong></a>)</span></strong>). Overall, model structure, design, and suggested parameters were informed by relevant literature <em><span class="citation" data-cites="pedersen2019">(<a href="#ref-pedersen2019" role="doc-biblioref"><strong>pedersen2019?</strong></a>)</span></em>. In some cases where expanded residual distribution family options were need to establish an appropriate model fit for more narrowly subsetted data, the original and more flexible gam() funciton in the ‘mgcv’ package was used with restricted maximum likelihood method (REML), which reports slightly differently, such as ‘deviance explained’ instead of R2 in ‘lme4’ package methods underlying ‘gamm4’. In these cases the choice of gam() over a gamm4() fit with similar family parameters was validated by comparing model AIC values.</p>
<p>Statistical models were run using raw relative abundances rounded to integers as response variables rather than proportions, to more simply validate the use of available distribution families in the packages, namely ‘poisson’ over ‘betar’. Values that were NA were omitted during GAMM model runs and ordinations as necessary. To maximize parsimony of model inferences from our study, main reported GAMMs were structured using only leaf habit as a fixed effect, and we use qualitative discussion to report differences inter-specific variation among plots within a single leaf habit (i.e.&nbsp;host tree species). Specifically, smooths were calculated for week of year for sampling date, to distinguish two sampling dates in the same month of June, with maximum ‘curvature’ knots (<em>k</em>) equal to seven; fixed effects included leaf habit (when models were not separated by plot for key week extraction), which in this case also aligned with the evolutionary group factor of angiosperm or gymnosperm; and random effects included subplot, where numbers were unique across plots but not across sampling dates, such that they were interpreted as subplots nested within monodominant plots (<strong>Table S1</strong>). Separate GAMMs were run for each exploration type and most abundant taxon, as community sequence and abundance data as response variables were only available at the finer genus and exploration-type level, which assumes reasonable importance of taxon and exploration type for observed phenological patterns. All GAMMs were checked for validity, primarily focusing on the appearance of 1:1 line alignments in Q-Q plots, and some additional checks for curvature flexibility, i.e.&nbsp;k’&gt;1 and associated p&gt;0.05 using the mgcv::gam.check() function (<strong><span class="citation" data-cites="CITE">(<a href="#ref-CITE" role="doc-biblioref"><strong>CITE?</strong></a>)</span>?</strong>).</p>
<p>Results visualizations show summed abundances by ECM binning factor, include zeros adjusted by adding one to maintain visualization when log-transformed, and median values are the central tendencies.</p>
</section>
<section id="critical-dates" class="level3">
<h3 class="anchored" data-anchor-id="critical-dates"><em>Critical dates</em></h3>
<p>To advance qualitative analysis of key phenological changes <em><span class="citation" data-cites="radville2016">(<a href="#ref-radville2016" role="doc-biblioref"><strong>radville2016?</strong></a>)</span></em> in our times series data, key weeks for dynamic changes were extracted from separate GAMMs that were run for each plot using gratia::derivatives() and identifying weeks where its sign changed between positive and/or negative <em><span class="citation" data-cites="simpson2018 simpson2024">(<a href="#ref-simpson2018" role="doc-biblioref"><strong>simpson2018?</strong></a>; <a href="#ref-simpson2024" role="doc-biblioref"><strong>simpson2024?</strong></a>)</span></em>.</p>
<p><em>- CVp calculated using mad/median and similar hypotheses tested using the same GAMM structure.</em></p>
</section>
<section id="composition" class="level3">
<h3 class="anchored" data-anchor-id="composition"><em>Composition</em></h3>
<p>For whole-community analyses, a PERMANOVA was run using all data as implemented in the ‘vegan’ package defaulting to 999 permutations. Abundance values were increased by one to resolve valid NA values, which thereby included taxa that passed our previous ten-read bioinformatic cutoff to not be interpreted as sequencing noise or index bleed, and also passed rarefaction, but were detected nonetheless as absent <em><span class="citation" data-cites="willis2019 tatsumi2023">(<a href="#ref-willis2019" role="doc-biblioref"><strong>willis2019?</strong></a>; <a href="#ref-tatsumi2023" role="doc-biblioref"><strong>tatsumi2023?</strong></a>)</span></em>. As PERMANOVA can be influenced by differences in either center location or variation within a cluster of samples <em><span class="citation" data-cites="warton2012 anderson2001">(<a href="#ref-warton2012" role="doc-biblioref"><strong>warton2012?</strong></a>; <a href="#ref-anderson2001" role="doc-biblioref"><strong>anderson2001?</strong></a>)</span></em>, we also explored community dispersion as a measure of beta diversity <em><span class="citation" data-cites="anderson2006a anderson2006b">(<a href="#ref-anderson2006a" role="doc-biblioref"><strong>anderson2006a?</strong></a>; <a href="#ref-anderson2006b" role="doc-biblioref"><strong>anderson2006b?</strong></a>)</span></em> with a PERMDISP using the betadisper() function from the ‘vegan’ package.</p>

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-midgley2020" class="csl-entry" role="listitem">
Midgley, Meghan G., and Rachel S. Sims. 2020. <span>“Mycorrhizal Association Better Predicts Tree Effects on Soil Than Leaf Habit.”</span> <em>Frontiers in Forests and Global Change</em> 3 (June): 74. <a href="https://doi.org/10.3389/ffgc.2020.00074">https://doi.org/10.3389/ffgc.2020.00074</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>